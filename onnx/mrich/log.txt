   ------------------------------------------------------------------
  | Welcome to ROOT 6.26/06                        https://root.cern |
  | (c) 1995-2021, The ROOT Team; conception: R. Brun, F. Rademakers |
  | Built for linuxx8664gcc on Nov 24 2022, 11:43:00                 |
  | From tags/v6-26-06@v6-26-06                                      |
  | With c++ (GCC) 12.2.0                                            |
  | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q'       |
   ------------------------------------------------------------------


Processing mcbm_reco_rich_only.C...
In file included from input_line_8:1:
In file included from /home/robin/mcbm-ring-reco/onnx/mrich_denoisenn/mcbm_reco_rich_only.C:20:
/home/robin/mcbm-ring-reco/onnx/mrich_denoisenn/QA_eventbased.cxx:82:20: error: no member named 'GetNNResponse' in 'CbmRichHit'
          if (hit->GetNNResponse() > 0.5) {
              ~~~  ^
In file included from input_line_8:1:
/home/robin/mcbm-ring-reco/onnx/mrich_denoisenn/mcbm_reco_rich_only.C:60:3: error: unknown type name 'CbmSetup'
  CbmSetup* setup = CbmSetup::Instance();
  ^
/home/robin/mcbm-ring-reco/onnx/mrich_denoisenn/mcbm_reco_rich_only.C:60:21: error: use of undeclared identifier 'CbmSetup'
  CbmSetup* setup = CbmSetup::Instance();
                    ^
/home/robin/mcbm-ring-reco/onnx/mrich_denoisenn/mcbm_reco_rich_only.C:112:3: error: unknown type name 'CbmMcbm2018EventBuilder'
  CbmMcbm2018EventBuilder* eventBuilder = new CbmMcbm2018EventBuilder();
  ^
/home/robin/mcbm-ring-reco/onnx/mrich_denoisenn/mcbm_reco_rich_only.C:112:47: error: unknown type name 'CbmMcbm2018EventBuilder'
  CbmMcbm2018EventBuilder* eventBuilder = new CbmMcbm2018EventBuilder();
                                              ^
/home/robin/mcbm-ring-reco/onnx/mrich_denoisenn/mcbm_reco_rich_only.C:115:37: error: use of undeclared identifier 'EventBuilderAlgo'
  eventBuilder->SetEventBuilderAlgo(EventBuilderAlgo::FixedTimeWindow);
                                    ^
/home/robin/mcbm-ring-reco/onnx/mrich_denoisenn/mcbm_reco_rich_only.C:130:5: error: unknown type name 'CbmRichMCbmHitProducer'
    CbmRichMCbmHitProducer* richHitProd = new CbmRichMCbmHitProducer();
    ^
/home/robin/mcbm-ring-reco/onnx/mrich_denoisenn/mcbm_reco_rich_only.C:130:47: error: unknown type name 'CbmRichMCbmHitProducer'
    CbmRichMCbmHitProducer* richHitProd = new CbmRichMCbmHitProducer();
                                              ^
/home/robin/mcbm-ring-reco/onnx/mrich_denoisenn/mcbm_reco_rich_only.C:142:5: error: unknown type name 'CbmRichReconstruction'
    CbmRichReconstruction* richReco = new CbmRichReconstruction();
    ^
/home/robin/mcbm-ring-reco/onnx/mrich_denoisenn/mcbm_reco_rich_only.C:142:43: error: unknown type name 'CbmRichReconstruction'
    CbmRichReconstruction* richReco = new CbmRichReconstruction();
                                          ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class FairParRootFileIo with content:

#line 1 "G__ParBase dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRCONTFACT_H
#define FAIRCONTFACT_H

#include <Rtypes.h>    // for Bool_t, ClassDef, etc
#include <TList.h>     // for TList
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString

class FairLogger;
class FairParIo;
class FairParSet;

class FairContainer : public TNamed
{
  private:
    FairContainer();
    FairContainer(const FairContainer&);
    FairContainer& operator=(const FairContainer&);

  protected:
    /** available contexts for this parameter container*/
    TList* contexts;
    /** actual context set by the user */
    TString actualContext;
    /** Fair Logger */
    FairLogger* fLogger;   //!

  public:
    FairContainer(const char*, const char*, const char*);
    ~FairContainer();
    void addContext(const char*);
    Bool_t setActualContext(const char* c);
    const char* getDefaultContext();
    const char* getActualContext() { return actualContext.Data(); }
    void print();
    TString getConcatName();
    const char* getContext();
    ClassDef(FairContainer, 0);   // class for list elements in class FairContFact
};

class FairContFact : public TNamed
{
  public:
    FairContFact();
    virtual ~FairContFact();
    Bool_t addContext(const char* name);
    void print();
    FairParSet* getContainer(const char*);
    virtual FairParSet* createContainer(FairContainer*) { return 0; }
    virtual void activateParIo(FairParIo*) {}
    /// @param[in] container Transfers ownership if return value is true
    Bool_t AddContainer(FairContainer*);

  protected:
    TList* containers;   // all parameter containers managed by this factory
    const char* getActualContext(const char* name)
    {
        return (static_cast<FairContainer*>(containers->FindObject(name)))->getActualContext();
    }
    /** Fair Logger */
    FairLogger* fLogger;         //!
    ClassDef(FairContFact, 0);   // base class of all factories for parameter containers

  private:
    FairContFact(const FairContFact&);
    FairContFact& operator=(const FairContFact&);
};

#endif /* !FAIRCONTFACT_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETPARASCIIFILEIO_H
#define FAIRDETPARASCIIFILEIO_H

#include "FairDetParIo.h"   // for FairDetParIo

#include <Rtypes.h>    // for Text_t, Bool_t, etc
#include <TString.h>   // for TString
#include <iosfwd>      // for fstream

class FairParSet;

class FairDetParAsciiFileIo : public FairDetParIo
{
  protected:
    TString fHeader;       //! header of container output in file
    TString sepLine;       //! comment line
    std::fstream* pFile;   //! pointer to ascii file
    // virtual Bool_t write(HDetector*) {return kTRUE;}
    Bool_t findContainer(const Text_t* name);
    Bool_t checkAllFound(Int_t*, Int_t);
    void writeHeader(const Text_t*,
                     const Text_t* context = "",
                     const Text_t* author = "",
                     const Text_t* description = "");
    void writeComment(FairParSet*);
    void readComment(const Char_t*, FairParSet*);
    // Bool_t readLabPositions(const Text_t*,HDetGeomPar*,Int_t*,Int_t,Int_t);
    // Bool_t readVolumes(const Text_t*,HDetGeomPar*);
    // void readTransform(HGeomTransform&);
    // Bool_t readVolume(HGeomVolume*,HGeomShapes*,Text_t*);
    // void writeTransform(const HGeomTransform&);
    // void writeVolume(HGeomVolume*,HGeomShapes*);

  public:
    FairDetParAsciiFileIo(std::fstream* f);
    virtual ~FairDetParAsciiFileIo() {}
    // Bool_t read(HDetGeomPar*,Int_t*);
    // Int_t writeFile(HDetGeomPar*);

  private:
    FairDetParAsciiFileIo& operator=(const FairDetParAsciiFileIo&);
    FairDetParAsciiFileIo(const FairDetParAsciiFileIo&);

    ClassDef(FairDetParAsciiFileIo, 0);   // Class for detector parameter I/O from ascii file
};

#endif /* !FAIRDETPARASCIIFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETPARIO_H
#define FAIRDETPARIO_H

#include <Rtypes.h>   // for Int_t, FairDetParIo::Class, etc
#include <TNamed.h>   // for TNamed

class FairParSet;

class FairDetParIo : public TNamed
{
  protected:
    Int_t inputNumber;   // input number (first or second input in runtime database)

  public:
    FairDetParIo();
    virtual ~FairDetParIo() { ; }

    // sets the input number
    void setInputNumber(Int_t n) { inputNumber = n; }

    // returns the input number
    Int_t getInputNumber() { return inputNumber; }

    // initializes parameter container
    virtual Bool_t init(FairParSet*) { return kFALSE; }

    // writes parameter container to output
    virtual Int_t write(FairParSet*) { return kFALSE; }

    ClassDef(FairDetParIo, 0);   // Base class for detector parameter IO
};

#endif /* !HDETPARIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETPARROOTFILEIO_H
#define FAIRDETPARROOTFILEIO_H

#include "FairDetParIo.h"   // for FairDetParIo

#include <Rtypes.h>   // for Int_t, Text_t, etc

class FairParRootFile;
class FairParSet;
class TObject;

class FairDetParRootFileIo : public FairDetParIo
{
  protected:
    FairParRootFile* pFile;   // pointer to parameter ROOT file

  public:
    FairDetParRootFileIo(FairParRootFile* f);
    virtual ~FairDetParRootFileIo() {}
    virtual Bool_t read(FairParSet*);
    Int_t write(FairParSet*);
    // Bool_t read(HDetGeomPar*,Int_t*);

  protected:
    Int_t findInputVersion(Text_t* contName);
    Int_t getMaxVersion(Text_t* contName);
    TObject* findContainer(Text_t* contName, Int_t version);

  private:
    FairDetParRootFileIo(const FairDetParRootFileIo&);
    FairDetParRootFileIo& operator=(const FairDetParRootFileIo&);

    ClassDef(FairDetParRootFileIo, 0);   // detector base class for parameter I/O from ROOT file
};

#endif /* !FAIRDETPARROOTFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGENERICPARASCIIFILEIO_H
#define FAIRGENERICPARASCIIFILEIO_H

#include "FairDetParAsciiFileIo.h"   // for FairDetParAsciiFileIo

#include <Rtypes.h>   // for Int_t, Bool_t, etc
#include <iosfwd>     // for fstream

class FairParGenericSet;
class FairParSet;
class TString;

class FairGenericParAsciiFileIo : public FairDetParAsciiFileIo
{
  public:
    FairGenericParAsciiFileIo(std::fstream* f = 0);
    ~FairGenericParAsciiFileIo() {}
    Bool_t init(FairParSet*);
    Int_t write(FairParSet*);

  private:
    ClassDef(FairGenericParAsciiFileIo,
             0)   // I/O from Ascii file for parameter containers derived from FairParGenericSet
        Bool_t readGenericSet(FairParGenericSet* pPar);
    Int_t writeGenericSet(FairParGenericSet* pPar);

    template<class type>
    const UChar_t* readData(type, const Char_t*, TString&, Int_t&);
    template<class type>
    void writeData(type*, Int_t);
};

#endif /* !FAIRGENERICPARASCIIFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGENERICPARROOTFILEIO_H
#define FAIRGENERICPARROOTFILEIO_H

#include "FairDetParRootFileIo.h"   // for FairDetParRootFileIo

#include <Rtypes.h>   // for ClassDef macro

class FairParRootFile;
class FairParSet;

class FairGenericParRootFileIo : public FairDetParRootFileIo
{
  public:
    FairGenericParRootFileIo(FairParRootFile* f = 0);
    ~FairGenericParRootFileIo() {}
    Bool_t init(FairParSet*);
    ClassDef(FairGenericParRootFileIo,
             0)   // I/O from ROOT file for parameter containers derived from FairParGenericSet
};

#endif /* !FAIRGENERICPARROOTFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARAMLIST_H
#define FAIRPARAMLIST_H

#include <Rtypes.h>           // for Text_t, Int_t, Bool_t, etc
#include <TArrayC.h>          // for TArrayC
#include <TFile.h>            // for TFile
#include <THashTable.h>       // for THashTable
#include <TNamed.h>           // for TNamed
#include <TObject.h>          // for TObject
#include <TROOT.h>            // for TROOT, gROOT
#include <TSeqCollection.h>   // for TSeqCollection
#include <TString.h>          // for TString

class TArrayD;
class TArrayF;
class TArrayI;

class FairParamObj : public TNamed
{
  protected:
    UChar_t* paramValue;      // Pointer to binary array
    Int_t arraySize;          // Size of binary array
    TString paramType;        // Type of parameter value or class name
    Bool_t basicType;         // kTRUE for C-types and C-type parameter arrays, kFALSE for classes
    Int_t bytesPerValue;      // number of bytes per value
    Int_t classVersion;       // Code version of classes stored as binary
    UChar_t* streamerInfo;    // Pointer to binary array container the streamer info
    Int_t streamerInfoSize;   // Size of streamer info array

  public:
    FairParamObj(const Text_t* name = "");
    FairParamObj(FairParamObj&);
    FairParamObj(const Text_t*, Int_t);
    FairParamObj(const Text_t*, Bool_t);
    FairParamObj(const Text_t*, UInt_t);
    FairParamObj(const Text_t*, Float_t);
    FairParamObj(const Text_t*, Double_t);
    FairParamObj(const Text_t*, const Int_t*, const Int_t);
    FairParamObj(const Text_t*, const UInt_t*, const Int_t);
    FairParamObj(const Text_t*, const Float_t*, const Int_t);
    FairParamObj(const Text_t*, const Double_t*, const Int_t);
    FairParamObj(const Text_t*, const Text_t*);
    FairParamObj(const Text_t*, const Char_t*, const Int_t);
    FairParamObj(const Text_t*, const UChar_t*, const Int_t);
    ~FairParamObj();
    void setParamType(const Text_t* t);
    UChar_t* setLength(Int_t l);
    void setParamValue(UChar_t*, const Int_t);
    void setClassVersion(const Int_t v) { classVersion = v; }
    UChar_t* setStreamerInfoSize(Int_t);
    void setStreamerInfo(UChar_t*, const Int_t);
    UChar_t* getParamValue() { return paramValue; }
    Bool_t isBasicType() { return basicType; }
    const char* getParamType() { return paramType.Data(); }
    Int_t getBytesPerValue() { return bytesPerValue; }
    Int_t getClassVersion() { return classVersion; }
    Int_t getLength() { return arraySize; }
    Int_t getNumParams();
    UChar_t* getStreamerInfo() { return streamerInfo; }
    Int_t getStreamerInfoSize() { return streamerInfoSize; }
    void print();

  protected:
    template<class type>
    void printData(type*, Int_t);

  private:
    FairParamObj& operator=(const FairParamObj&);

    // Class for binary parameter object (name + binary array)
    ClassDef(FairParamObj, 0);
};

class FairParamList : public TObject
{
  protected:
    THashTable paramList;   // List for parameters stored as string
    class FairParamTFile : public TFile
    {
      public:
        FairParamTFile()
        {
            // Create StreamerInfo index
            Int_t lenIndex = gROOT->GetListOfStreamerInfo()->GetSize() + 1;
            if (lenIndex < 5000) {
                lenIndex = 5000;
            }
            fClassIndex = new TArrayC(lenIndex);
        }
        ~FairParamTFile()
        {
            delete fClassIndex;
            fClassIndex = 0;
        }
    };

  public:
    FairParamList();
    ~FairParamList();
    void add(FairParamObj&);
    void add(const Text_t*, const Text_t*);
    void add(const Text_t*, Int_t);
    void add(const Text_t*, Bool_t);
    void add(const Text_t*, UInt_t);
    void add(const Text_t*, Float_t);
    void add(const Text_t*, Double_t);
    void add(const Text_t*, TArrayI&);
    void add(const Text_t*, TArrayC&);
    void add(const Text_t*, TArrayF&);
    void add(const Text_t*, TArrayD&);
    void add(const Text_t*, const UChar_t*, const Int_t);
    void add(const Text_t*, const Int_t*, const Int_t);
    void add(const Text_t*, const Float_t*, const Int_t);
    void add(const Text_t*, const Double_t*, const Int_t);
    void addObject(const Text_t*, TObject*);
    Bool_t fill(const Text_t*, Text_t*, const Int_t);
    Bool_t fill(const Text_t*, Int_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, Bool_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, UInt_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, Float_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, Double_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, UChar_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, TArrayI*);
    Bool_t fill(const Text_t*, TArrayC*);
    Bool_t fill(const Text_t*, TArrayF*);
    Bool_t fill(const Text_t*, TArrayD*);
    Bool_t fillObject(const Text_t*, TObject*);
    void print();
    FairParamObj* find(const Text_t* name) { return static_cast<FairParamObj*>(paramList.FindObject(name)); }
    THashTable* getList() { return &paramList; }

  private:
    FairParamList(const FairParamList&);
    FairParamList& operator=(const FairParamList&);

    // Class for lists of parameters (of type FairParamObj)
    ClassDef(FairParamList, 4);
};

#endif /* !FAIRPARAMLIST_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARASCIFILEIIO_H
#define FAIRPARASCIFILEIIO_H

#include "FairParIo.h"   // for FairParIo

#include <Rtypes.h>   // for Bool_t, Text_t, etc
#include <fstream>    // for fstream, etc

class TList;

class FairParAsciiFileIo : public FairParIo
{
  protected:
    std::fstream* file;   // pointer to a file

  public:
    FairParAsciiFileIo();

    // default destructor closes an open file and deletes list of I/Os
    ~FairParAsciiFileIo();

    // opens file
    // if a file is already open, this file will be closed
    // activates detector I/Os
    Bool_t open(const Text_t* fname, const Text_t* status = "in");

    // concatenate files whose names are stored in the TList
    // TList holds list od TObjStrings
    // create file all.par in local working directory
    // calls open to open the generated file all.par
    Bool_t open(const TList* fnamelist, const Text_t* status = "in");

    // closes file
    void close();

    // returns kTRUE if file is open
    Bool_t check()
    {
        if (file) {
            return (file->rdbuf()->is_open() == 1);
        } else {
            return kFALSE;
        }
    }

    // prints information about the file and the detector I/Os
    void print();

    std::fstream* getFile();

  private:
    FairParAsciiFileIo(const FairParAsciiFileIo&);
    FairParAsciiFileIo& operator=(const FairParAsciiFileIo&);

    ClassDef(FairParAsciiFileIo, 0);   // Parameter I/O from ASCII files
};

#endif /* !FAIRPARASCIIFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARGENERICSET_H
#define FAIRPARGENERICSET_H

#include "FairParSet.h"   // for FairParSet

#include <Rtypes.h>   // for Bool_t, etc

class FairParIo;
class FairParamList;

class FairParGenericSet : public FairParSet
{
  public:
    FairParGenericSet(const char* name, const char* title, const char* context, Bool_t ownership = kFALSE)
        : FairParSet(name, title, context, ownership)
    {}
    virtual ~FairParGenericSet() {}
    virtual void putParams(FairParamList*) = 0;
    virtual Bool_t getParams(FairParamList*) = 0;
    virtual void printParams();

    Bool_t init(FairParIo* inp);
    Int_t write(FairParIo* output);

    // DB add on
    void fill(UInt_t){};
    void store(UInt_t){};

  protected:
    FairParGenericSet()
        : FairParSet()
    {}
    ClassDef(FairParGenericSet, 1);   // Base class for generic-style parameter containers
};

#endif /* !FAIRPARGENERICSET_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARIO_H
#define FAIRPARIO_H

#include <Rtypes.h>    // for Bool_t, Text_t, etc
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString

class FairDetParIo;
class FairRtdbRun;
class TList;

class FairParIo : public TObject
{
  protected:
    TList* detParIoList;   // list of detector I/Os
    Bool_t autoWritable;   // flag indicating if automatic write is possible
    TString filename;

  public:
    FairParIo();
    virtual ~FairParIo();
    virtual FairDetParIo* getDetParIo(const Text_t*);
    virtual void setDetParIo(FairDetParIo*);
    virtual void removeDetParIo(Text_t*);
    void setInputNumber(Int_t);
    virtual void close() { ; }

    // returns the filename
    const char* getFilename() { return filename.Data(); }

    // creates input/output class for a special detector and stores pointer
    // used only for Oracle input/output
    // (code in  class OraIo)
    virtual void setDetParIo(Text_t*) { ; }

    // prints information about input/output
    virtual void print() { ; }

    // checks if the input/output is open
    virtual Bool_t check() { return kFALSE; }

    // reads versions of parameter containers for an event file
    virtual void readVersions(FairRtdbRun*) { ; }

    // sets global file pointer in ROOT if input/output is a ROOT-file
    // (code in FairParRootFileIo)
    virtual void cd() { ; }

    // set and get for flag autoWritable
    void setAutoWritable(Bool_t f = kTRUE) { autoWritable = f; }
    Bool_t isAutoWritable() { return autoWritable; }

  private:
    FairParIo(const FairParIo&);
    FairParIo& operator=(const FairParIo&);

    ClassDef(FairParIo, 0);   // Base class for all parameter I/Os
};

#endif /* !FAIRPARIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARROOTFILEIO_H
#define FAIRPARROOTFILEIO_H

#include "FairParIo.h"   // for FairParIo

#include <Rtypes.h>   // for Bool_t, Text_t, Int_t, etc
#include <TFile.h>    // for TFile
#include <TNamed.h>   // for TNamed
#include <fstream>
using std::fstream;

class FairRtdbRun;
class TKey;
class TList;

class FairParRootFile : public TNamed
{
  public:
    FairRtdbRun* run;   //! pointer to current run in ROOT file
    FairParRootFile(const Text_t* fname, Option_t* option = "READ", const Text_t* ftitle = "", Int_t compress = 1);
    FairParRootFile(TFile* f);
    ~FairParRootFile();
    FairRtdbRun* getRun() { return run; }
    void readVersions(FairRtdbRun*);

    Bool_t IsOpen() { return RootFile->IsOpen(); }
    void cd() { RootFile->cd(); }
    Bool_t IsWritable() { return RootFile->IsWritable(); }

    TKey* GetKey(Text_t* t) { return RootFile->GetKey(t); }
    TList* GetListOfKeys() { return RootFile->GetListOfKeys(); }
    void Close() { RootFile->Close(); }

  protected:
    TFile* RootFile;

  private:
    FairParRootFile(const FairParRootFile&);
    FairParRootFile& operator=(const FairParRootFile&);

    ClassDef(FairParRootFile, 0);   // ROOT file for Parameter I/O
};

class FairParRootFileIo : public FairParIo
{
  protected:
    FairParRootFile* file;   // pointer to ROOT file
    Bool_t fMerging;

  public:
    FairParRootFileIo();
    FairParRootFileIo(Bool_t merged);
    ~FairParRootFileIo();
    Bool_t open(const Text_t* fname, Option_t* option = "READ", const Text_t* ftitle = "", Int_t compress = 1);
    Bool_t open(const TList* fnamelist, Option_t* option = "READ", const Text_t* ftitle = "", Int_t compress = 1);
    void close();
    void print();
    FairParRootFile* getParRootFile();
    void readVersions(FairRtdbRun*);
    TList* getKeys();
    Bool_t check()
    {
        // returns kTRUE if file is open
        if (file) {
            return file->IsOpen();
        } else {
            return kFALSE;
        }
    }
    void cd()
    {
        // sets the global ROOT file pointer gFile
        if (file) {
            file->cd();
        }
    }
    /**
    Open an existing root file for IO
    */
    Bool_t open(TFile* f);
    void setMerging(Bool_t io) { fMerging = io; }

  private:
    FairParRootFileIo(const FairParRootFileIo&);
    FairParRootFileIo& operator=(const FairParRootFileIo&);

    ClassDef(FairParRootFileIo, 0);   // Parameter I/O from ROOT files
};

#endif /* !FAIRPARROOTFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARSET_H
#define FAIRPARSET_H

#include <Rtypes.h>   // for Int_t, Bool_t, etc
#include <TObject.h>
#include <TString.h>   // for TString

class FairLogger;
class FairParIo;

class FairParSet : public TObject
{
  protected:
    TString fName;          //
    TString fTitle;         //
    TString detName;        //! name of the detector the container belongs to
    Int_t versions[3];      //! versions of container in the 2 possible inputs
    Bool_t status;          //! static flag
    Bool_t changed;         //! flag is kTRUE if parameters have changed
    Bool_t owned;           //! if flag is KTRUE FairDB has the par. class ownership
    TString paramContext;   // Context/purpose for parameters and conditions
    TString author;         // Author of parameters
    TString description;    // Description of parameters
    /** Fair Logger */
    FairLogger* fLogger;   //!

  public:
    FairParSet(const char* name = "", const char* title = "", const char* context = "", Bool_t owner = kFALSE);
    virtual ~FairParSet() {}

    virtual const char* GetName() const { return static_cast<const char*>(fName.Data()); }
    virtual const char* GetTitle() const { return static_cast<const char*>(fTitle.Data()); }

    virtual Bool_t init();
    virtual Bool_t init(FairParIo*) { return kFALSE; }
    virtual Int_t write();
    virtual Int_t write(FairParIo*) { return kFALSE; }
    virtual void clear() {}
    virtual void print();

    const char* getDetectorName() { return detName.Data(); }
    void resetInputVersions();

    void setInputVersion(Int_t v = -1, Int_t i = 0)
    {
        if (i >= 0 && i < 3) {
            versions[i] = v;
        }
    }
    Int_t getInputVersion(Int_t i)
    {
        if (i >= 0 && i < 3) {
            return versions[i];
        } else {
            return 0;
        }
    }

    void setStatic(Bool_t flag = kTRUE) { status = flag; }
    Bool_t isStatic() { return status; }

    void setOwnership(Bool_t flag = kTRUE) { owned = flag; }
    Bool_t isOwned() { return owned; }

    void setChanged(Bool_t flag = kTRUE) { changed = flag; }
    Bool_t hasChanged() { return changed; }

    const char* getParamContext() const { return paramContext.Data(); }

    void setAuthor(const char* s) { author = s; }
    const char* getAuthor() const { return author.Data(); }

    void setDescription(const char* s) { description = s; }
    const char* getDescription() const { return description.Data(); }

    void copyComment(FairParSet& r)
    {
        author = r.getAuthor();
        description = r.getDescription();
    }

    virtual void fill(UInt_t){};
    virtual void store(UInt_t){};

    FairParSet& operator=(const FairParSet&);
    FairParSet(const FairParSet&);

    ClassDef(FairParSet, 2);   // Base class for all parameter containers
};

#endif /* !FAIRPARSET_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRTDBRUN_H
#define FAIRRTDBRUN_H

#include <Rtypes.h>    // for Int_t, Text_t, UInt_t, etc
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString
#include <iosfwd>      // for fstream
#include <stdio.h>     // for sprintf, sscanf

class TList;
using std::fstream;

class FairParVersion : public TNamed
{
  protected:
    Int_t inputVersions[3];   //! version of the parameter container in the 2 possible inputs
    Int_t rootVersion;        // version of the parameter container in the ROOT output file

  public:
    FairParVersion()
        : TNamed()
        , rootVersion(0)
    {}
    FairParVersion(Text_t* name);
    ~FairParVersion() {}
    void setInputVersion(Int_t v = -1, Int_t i = 0)
    {
        if (i >= 0 && i < 3) {
            inputVersions[i] = v;
        }
    }
    Int_t getInputVersion(Int_t i)
    {
        if (i >= 0 && i < 3) {
            return inputVersions[i];
        } else {
            return -1;
        }
    }
    void resetInputVersions()
    {
        for (Int_t i = 0; i < 3; i++) {
            inputVersions[i] = -1;
        }
    }
    void setRootVersion(Int_t v) { rootVersion = v; }
    Int_t getRootVersion() { return rootVersion; }
    ClassDef(FairParVersion, 1);   // Class for parameter versions
};

class FairRtdbRun : public TNamed
{
  protected:
    TList* parVersions;   // List of container names with the versions
    TString refRun;       //! name of the reference run for initialization

  public:
    FairRtdbRun();
    FairRtdbRun(const Text_t* name, const Text_t* refName = "");
    FairRtdbRun(Int_t r, Int_t rr = -1);
    FairRtdbRun(FairRtdbRun& run);
    ~FairRtdbRun();
    inline UInt_t getRunId(void);
    void addParVersion(FairParVersion* pv);
    FairParVersion* getParVersion(const Text_t* name);
    TList* getParVersions() { return parVersions; }
    const Text_t* getRefRun() { return refRun.Data(); }
    void setRefRun(Text_t* s) { refRun = s; }
    inline void setRefRun(Int_t r);
    void resetInputVersions();
    void resetOutputVersions();
    void print();
    void write(std::fstream&);

  private:
    FairRtdbRun& operator=(const FairRtdbRun&);

    ClassDef(FairRtdbRun, 1);   // Class for parameter version management of a run
};

// -------------------- inlines ---------------------------

inline UInt_t FairRtdbRun::getRunId(void)
{
    UInt_t r;
    sscanf(GetName(), "%i", &r);
    return r;
}

inline void FairRtdbRun::setRefRun(Int_t r)
{
    if (r == -1) {
        refRun = "";
    } else {
        char name[255];
        sprintf(name, "%i", r);
        refRun = name;
    }
}

#endif /* !FAIRRTDBRUN_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNTIMEDB_H
#define FAIRRUNTIMEDB_H

#include <Rtypes.h>    // for Bool_t, Int_t, Text_t, etc
#include <TList.h>     // for TList
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString

class FairContFact;
class FairLogger;
class FairParIo;
class FairParSet;
class FairRtdbRun;

static TList contFactories;   //! list of container factories

class FairRuntimeDb : public TObject
{
  private:
    static FairRuntimeDb* gRtdb;   //!

  protected:
    FairRuntimeDb(void);
    TList* containerList;      // list of parameter containers
    TList* runs;               // list of runs
    FairParIo* firstInput;     // first (prefered) input for parameters
    FairParIo* secondInput;    // second input (used if not found in first input)
    FairParIo* output;         // output for parameters
    FairRtdbRun* currentRun;   // Current run
    TString currentFileName;   // Name of current event file
    Bool_t versionsChanged;    // flag for write of list of runs (set kTRUE by each write)
    Bool_t isRootFileOutput;   // flag indicating that the output is a ROOT file
    /** Fair Logger */
    FairLogger* fLogger;   //!

    /**
     * Select which IO type to use.
     */
    typedef enum
    {
        UNKNOWN_Type = 0,
        AsciiFileOutput = 1,   // Ascii in-out-put
        RootFileOutput = 2,    // Root Files
        RootTSQLOutput = 3     // Use a TSQL db
    } ParamIOType;
    ParamIOType ioType;   // IO Type

  public:
    static FairRuntimeDb* instance(void);
    ~FairRuntimeDb(void);

    Bool_t addParamContext(const char*);
    void printParamContexts();
    void addContFactory(FairContFact*);
    void removeContFactory(FairContFact* fact);
    FairContFact* getContFactory(const Text_t*);

    Bool_t addContainer(FairParSet*);
    FairParSet* getContainer(const Text_t*);
    FairParSet* findContainer(const char*);
    void removeContainer(Text_t*);
    void removeAllContainers(void);
    Bool_t initContainers(Int_t runId, Int_t refId = -1, const Text_t* fileName = "");
    void setContainersStatic(Bool_t f = kTRUE);
    Bool_t writeContainers(void);
    Bool_t writeContainer(FairParSet*, FairRtdbRun*, FairRtdbRun* refRun = 0);

    FairRtdbRun* addRun(Int_t runId, Int_t refId = -1);
    FairRtdbRun* getRun(Int_t);
    FairRtdbRun* getRun(Text_t*);
    FairRtdbRun* getCurrentRun(void) { return currentRun; }
    Text_t const* getCurrentFileName() { return currentFileName.Data(); }
    void clearRunList(void);

    void removeRun(Text_t*);

    Bool_t setInputVersion(Int_t run, Text_t* container, Int_t version, Int_t inputNumber);
    Bool_t setRootOutputVersion(Int_t run, Text_t* container, Int_t version);
    void setVersionsChanged(Bool_t f = kTRUE) { versionsChanged = f; }
    void resetInputVersions(void);
    void resetOutputVersions(void);
    void resetAllVersions(void);

    Bool_t readAll(void);
    void writeVersions(void);
    void saveOutput(void);

    Bool_t setFirstInput(FairParIo*);
    Bool_t setSecondInput(FairParIo*);
    Bool_t setOutput(FairParIo*);
    FairParIo* getFirstInput(void);
    FairParIo* getSecondInput(void);
    FairParIo* getOutput(void);
    void closeFirstInput(void);
    void closeSecondInput(void);
    void closeOutput(void);
    void activateParIo(FairParIo*);
    TList* getListOfContainers() { return containerList; }
    void print(void);

    Int_t findOutputVersion(FairParSet*);

  private:
    FairRuntimeDb(const FairRuntimeDb& M);
    FairRuntimeDb& operator=(const FairRuntimeDb&) { return *this; }
    Bool_t initContainers(void);

    ClassDef(FairRuntimeDb, 0);   // Class for runtime database
};

#endif /* !FAIRRUNTIMEDB_H */

#undef  _BACKWARD_BACKWARD_WARNING_H

/home/robin/mcbm-ring-reco/onnx/mrich_denoisenn/mcbm_reco_rich_only.C:168:36: error: allocation of incomplete type 'FairParRootFileIo'
  FairParRootFileIo* parIo1  = new FairParRootFileIo();
                                   ^~~~~~~~~~~~~~~~~
G__ParBase dictionary forward declarations' payload:19:319: note: forward declaration of 'FairParRootFileIo'
class __attribute__((annotate(R"ATTRDUMP(Parameter I/O from ROOT files)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Parameter I/O from ROOT files)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Parameter I/O from ROOT files)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Parameter I/O from ROOT files)ATTRDUMP"))) FairParRootFileIo;
                                                                                                                                                                                                                                                                                                                              ^
In file included from input_line_8:1:
/home/robin/mcbm-ring-reco/onnx/mrich_denoisenn/mcbm_reco_rich_only.C:170:9: error: member access into incomplete type 'FairParRootFileIo'
  parIo1->open(parFile.Data(), "UPDATE");
        ^
G__ParBase dictionary forward declarations' payload:19:319: note: forward declaration of 'FairParRootFileIo'
class __attribute__((annotate(R"ATTRDUMP(Parameter I/O from ROOT files)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Parameter I/O from ROOT files)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Parameter I/O from ROOT files)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Parameter I/O from ROOT files)ATTRDUMP"))) FairParRootFileIo;
                                                                                                                                                                                                                                                                                                                              ^
In file included from input_line_8:1:
/home/robin/mcbm-ring-reco/onnx/mrich_denoisenn/mcbm_reco_rich_only.C:172:23: error: cannot initialize a parameter of type 'FairParIo *' with an lvalue of type 'FairParRootFileIo *'
  rtdb->setFirstInput(parIo1);
                      ^~~~~~
/home/robin/fair_install/FairRootInst/include/FairRuntimeDb.h:95:36: note: passing argument to parameter here
    Bool_t setFirstInput(FairParIo*);
                                   ^
In file included from input_line_8:1:
/home/robin/mcbm-ring-reco/onnx/mrich_denoisenn/mcbm_reco_rich_only.C:185:19: error: cannot initialize a parameter of type 'FairParIo *' with an lvalue of type 'FairParRootFileIo *'
  rtdb->setOutput(parIo1);
                  ^~~~~~
/home/robin/fair_install/FairRootInst/include/FairRuntimeDb.h:97:32: note: passing argument to parameter here
    Bool_t setOutput(FairParIo*);
                               ^
root.exe: /home/robin/fair_install/FairSoft/build/Source/root/interpreter/llvm/src/tools/clang/lib/AST/DeclCXX.cpp:1391: clang::CXXMethodDecl* clang::CXXRecordDecl::getLambdaCallOperator() const: Assertion `!Calls.empty() && "Missing lambda call operator!"' failed.
